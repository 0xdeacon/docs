"use strict";(self.webpackChunkcelestia_docs=self.webpackChunkcelestia_docs||[]).push([[4712],{3905:function(e,r,n){n.d(r,{Zo:function(){return d},kt:function(){return p}});var t=n(7294);function s(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function o(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function u(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?o(Object(n),!0).forEach((function(r){s(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function i(e,r){if(null==e)return{};var n,t,s=function(e,r){if(null==e)return{};var n,t,s={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||(s[n]=e[n]);return s}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var a=t.createContext({}),l=function(e){var r=t.useContext(a),n=r;return e&&(n="function"==typeof e?e(r):u(u({},r),e)),n},d=function(e){var r=l(e.components);return t.createElement(a.Provider,{value:r},e.children)},c={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},m=t.forwardRef((function(e,r){var n=e.components,s=e.mdxType,o=e.originalType,a=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=l(n),p=s,f=m["".concat(a,".").concat(p)]||m[p]||c[p]||o;return n?t.createElement(f,u(u({ref:r},d),{},{components:n})):t.createElement(f,u({ref:r},d))}));function p(e,r){var n=arguments,s=r&&r.mdxType;if("string"==typeof e||s){var o=n.length,u=new Array(o);u[0]=m;var i={};for(var a in r)hasOwnProperty.call(r,a)&&(i[a]=r[a]);i.originalType=e,i.mdxType="string"==typeof e?e:s,u[1]=i;for(var l=2;l<o;l++)u[l]=n[l];return t.createElement.apply(null,u)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9966:function(e,r,n){n.r(r),n.d(r,{assets:function(){return a},contentTitle:function(){return u},default:function(){return c},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return l}});var t=n(3117),s=(n(7294),n(3905));const o={sidebar_label:"Keeper"},u="Les fonctions de Keeper",i={unversionedId:"developers/wordle-keeper",id:"developers/wordle-keeper",title:"Les fonctions de Keeper",description:"Maintenant, il est temps d'ajouter les fonctions de keeper pour chaque message. \xc0 partir de la documentation du Cosmos-SDK, un Keeper est d\xe9fini de la fa\xe7on qui suit :",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/developers/wordle-keeper.md",sourceDirName:"developers",slug:"/developers/wordle-keeper",permalink:"/fr/developers/wordle-keeper",draft:!1,editUrl:"https://github.com/celestiaorg/docs/tree/main/docs/developers/wordle-keeper.md",tags:[],version:"current",frontMatter:{sidebar_label:"Keeper"},sidebar:"developers",previous:{title:"Types",permalink:"/fr/developers/wordle-types"},next:{title:"Run The Wordle Chain",permalink:"/fr/developers/run-wordle"}},a={},l=[{value:"Fonction SubmitWordle",id:"fonction-submitwordle",level:2},{value:"La fonction SubmitGuess",id:"la-fonction-submitguess",level:2},{value:"Le fichier Protobuf",id:"le-fichier-protobuf",level:2}],d={toc:l};function c(e){let{components:r,...n}=e;return(0,s.kt)("wrapper",(0,t.Z)({},d,n,{components:r,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"les-fonctions-de-keeper"},"Les fonctions de Keeper"),(0,s.kt)("p",null,"Maintenant, il est temps d'ajouter les fonctions de keeper pour chaque message. \xc0 partir de la documentation du Cosmos-SDK, un ",(0,s.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/master/building-modules/keeper.html"},"Keeper")," est d\xe9fini de la fa\xe7on qui suit :"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Le noyau principal d'un module Cosmos-SDK est une pi\xe8ce appel\xe9e le keeper. Le keeper g\xe8re les int\xe9ractions avec le stockage, a des r\xe9f\xe9rences \xe0 d'autres gardiens pour les int\xe9ractions entre modules et contient la plupart des fonctionnalit\xe9s de base d'un module.")),(0,s.kt)("p",null,"Keeper est une abstraction sur Cosmos qui nous permet d'interagir avec le stockage de Key-Value et de changer l'\xe9tat de la blockchain."),(0,s.kt)("p",null,"Ici, il nous aidera \xe0 d\xe9finir la logique de chaque message que nous cr\xe9ons."),(0,s.kt)("h2",{id:"fonction-submitwordle"},"Fonction SubmitWordle"),(0,s.kt)("p",null,"Nous allons commencer avec la fonction ",(0,s.kt)("inlineCode",{parentName:"p"},"SubmitWordle"),"."),(0,s.kt)("p",null,"Ouvrez le fichier suivant : ",(0,s.kt)("inlineCode",{parentName:"p"},"x/wordle/keeper/msg_server_submit_wordle.go")),(0,s.kt)("p",null,"A l'int\xe9rieur de ce qui suit, ajoutez le code suivant, que nous allons \xe9tudier plus loin :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'package keeper\n\nimport (\n  "context"\n  "crypto/sha256"\n  "encoding/hex"\n  "github.com/YazzyYaz/wordle/x/wordle/types"\n  sdk "github.com/cosmos/cosmos-sdk/types"\n  sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"\n  "time"\n  "unicode"\n)\n\nfunc (k msgServer) SubmitWordle(goCtx context.Context, msg *types.MsgSubmitWordle) (*types.MsgSubmitWordleResponse, error) {\n  ctx := sdk.UnwrapSDKContext(goCtx)\n  // Check to See the Wordle is 5 letters\n  if len(msg.Word) != 5 {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle Must Be A 5 Letter Word")\n  }\n  // Check to See Only Alphabets Are Passed for the Wordle\n  if !(IsLetter(msg.Word)) {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle Must Only Consist Of Letters In The Alphabet")\n  }\n\n  // Use Current Day to Create The Index of the Newly-Submitted Wordle of the Day\n  currentTime := time.Now().Local()\n  var currentTimeBytes = []byte(currentTime.Format("2006-01-02"))\n  var currentTimeHash = sha256.Sum256(currentTimeBytes)\n  var currentTimeHashString = hex.EncodeToString(currentTimeHash[:])\n  // Hash The Newly-Submitted Wordle of the Day\n  var submittedSolutionHash = sha256.Sum256([]byte(msg.Word))\n  var submittedSolutionHashString = hex.EncodeToString(submittedSolutionHash[:])\n\n  var wordle = types.Wordle{\n    Index:     currentTimeHashString,\n    Word:      submittedSolutionHashString,\n    Submitter: msg.Creator,\n  }\n\n  // Try to Get Wordle From KV Store Using Current Day as Key\n  // This Helps ensure only one Wordle is submitted per day\n  _, isFound := k.GetWordle(ctx, currentTimeHashString)\n  if isFound {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle of the Day is Already Submitted")\n  }\n  // Write Wordle to KV Store\n  k.SetWordle(ctx, wordle)\n  return &types.MsgSubmitWordleResponse{}, nil\n}\n\nfunc IsLetter(s string) bool {\n  for _, r := range s {\n    if !unicode.IsLetter(r) {\n      return false\n    }\n  }\n  return true\n}\n')),(0,s.kt)("p",null,"Ici, dans la fonction de keeper ",(0,s.kt)("inlineCode",{parentName:"p"},"SubmitWordle"),", nous allons faire certaines choses :"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Nous nous assurons d'abord que le mot soumis pour le mot du jour est long de 5 caract\xe8res et qu'il n'utilise que des lettres. Cela signifie qu'aucun nombre entier ne peut \xeatre \xeatre soumis dans la chaine."),(0,s.kt)("li",{parentName:"ul"},"Nous cr\xe9ons ensuite un hash \xe0 partir du jour en cours au moment o\xf9 le mot a \xe9t\xe9 soumis. Nous pla\xe7ons ce hash \xe0 l'index du type du Wordle. Cela nous permet de rechercher toutes les suppositions de ce mot pour les jeux suivants, que nous allons \xe9tudier ensuite."),(0,s.kt)("li",{parentName:"ul"},"Nous v\xe9rifions ensuite si l'index de la date du jour est actuellement vide ou non. S'il n'est pas vide, cela signifie qu'un mot a d\xe9j\xe0 \xe9t\xe9 soumis. Rappelez-vous qu'un seul mot seulement peut \xeatre soumis chaque jour. Tout le monde doit deviner le mot soumis."),(0,s.kt)("li",{parentName:"ul"},"Nous avons \xe9galement une fonction d'aide pour v\xe9rifier si une chaine de caract\xe8res contient seulement des caract\xe8res alphab\xe9tiques.")),(0,s.kt)("h2",{id:"la-fonction-submitguess"},"La fonction SubmitGuess"),(0,s.kt)("p",null,"La prochaine fonction de keeper que nous allons ajouter est la suivante : ",(0,s.kt)("inlineCode",{parentName:"p"},"x/wordle/keeper/msg_server_submit_guess.go")),(0,s.kt)("p",null,"Ouvrez ce fichier et ajoutez le code suivant, que nous allons expliquer un peu plus bas :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'package keeper\n\nimport (\n  "context"\n  "crypto/sha256"\n  "encoding/hex"\n  "github.com/YazzyYaz/wordle/x/wordle/types"\n  sdk "github.com/cosmos/cosmos-sdk/types"\n  sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"\n  "strconv"\n  "time"\n  "github.com/tendermint/tendermint/crypto"\n)\n\nfunc (k msgServer) SubmitGuess(goCtx context.Context, msg *types.MsgSubmitGuess) (*types.MsgSubmitGuessResponse, error) {\n  ctx := sdk.UnwrapSDKContext(goCtx)\n  // Check Word is 5 Characters Long\n  if len(msg.Word) != 5 {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Guess Must Be A 5 Letter Word!")\n  }\n\n  // Check String Contains Alphabet Letters Only\n  if !(IsLetter(msg.Word)) {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Guess Must Only Consist of Alphabet Letters!")\n  }\n\n  // Get Current Day to Pull Up Wordle of That Day As A Hash\n  currentTime := time.Now().Local()\n  var currentTimeBytes = []byte(currentTime.Format("2006-01-02"))\n  var currentTimeHash = sha256.Sum256(currentTimeBytes)\n  var currentTimeHashString = hex.EncodeToString(currentTimeHash[:])\n  wordle, isFound := k.GetWordle(ctx, currentTimeHashString)\n  if !isFound {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle of The Day Hasn\'t Been Submitted Yet.\n  }\n\n  // Check String Contains Alphabet Letters Only\n  if !(IsLetter(msg.Word)) {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Guess Must Only Consist of Alphabet Letters!")\n  }\n\n  // Get Current Day to Pull Up Wordle of That Day As A Hash\n  currentTime := time.Now().Local()\n  var currentTimeBytes = []byte(currentTime.Format("2006-01-02"))\n  var currentTimeHash = sha256.Sum256(currentTimeBytes)\n  var currentTimeHashString = hex.EncodeToString(currentTimeHash[:])\n  wordle, isFound := k.GetWordle(ctx, currentTimeHashString)\n  if !isFound {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle of The Day Hasn\'t Been Submitted Yet. Feel Free to Submit One!")\n  }\n\n  // We Convert Current Day and Guesser to A Hash To Use As An Index For Today\'s Guesses For That Guesser\n  // That Way, A Person Can Guess 6 Times A Day For Each New Wordle Created\n  var currentTimeGuesserBytes = []byte(currentTime.Format("2006-01-02") + msg.Creator)\n  var currentTimeGuesserHash = sha256.Sum256(currentTimeGuesserBytes)\n  var currentTimeGuesserHashString = hex.EncodeToString(currentTimeGuesserHash[:])\n  // Hash The Guess To The Wordle\n  var submittedSolutionHash = sha256.Sum256([]byte(msg.Word))\n  var submittedSolutionHashString = hex.EncodeToString(submittedSolutionHash[:])\n\n  // Get the Latest Guess entry for this Submitter for the current Wordle of the Day\n  var count int\n  guess, isFound := k.GetGuess(ctx, currentTimeGuesserHashString)\n  if isFound {\n    // Check if Submitter Reached 6 Tries\n    if guess.Count == strconv.Itoa(6) {\n      return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "You Have Guessed The Maximum Amount of Times for The Day! Try Again Tomorrow With A New Wordle.")\n    }\n    currentCount, err := strconv.Atoi(guess.Count)\n    if err != nil {\n      panic(err)\n    }\n    count = currentCount\n  } else {\n    // Initialize Count Value If No Entry Exists for this Submitter for Today\'s Wordle\n    count = 0\n  }\n  // Increment Guess Count\n  count += 1\n  var newGuess = types.Guess{\n    Index:     currentTimeGuesserHashString,\n    Submitter: msg.Creator,\n    Word:      submittedSolutionHashString,\n    Count:     strconv.Itoa(count),\n  }\n  // Remove Current Guess Entry to be Updated With New Entry\n  k.RemoveGuess(ctx, currentTimeGuesserHashString)\n  // Add New Guess Entry\n  k.SetGuess(ctx, newGuess)\n  // Setup Reward \n  reward := sdk.Coins{sdk.NewInt64Coin("WORDLE", 100)}\n  if !(wordle.Word == submittedSolutionHashString) {\n    return &types.MsgSubmitGuessResponse{Title: "Wrong Answer", Body: "Your Guess Was Wrong. Try Again"}, nil\n  } else {\n    // If Submitter Guesses Correctly\n    guesserAddress, _ := sdk.AccAddressFromBech32(msg.Creator)\n    moduleAcct := sdk.AccAddress(crypto.AddressHash([]byte(types.ModuleName)))\n    // Send Reward\n    k.bankKeeper.SendCoins(ctx, guesserAddress, moduleAcct, reward) \n    return &types.MsgSubmitGuessResponse{Title: "Correct", Body: "You Guessed The Wordle Correctly!"}, nil\n  }\n}\n')),(0,s.kt)("p",null,"Dans le code ci-dessus, nous effectuons les choses suivantes :"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Ici, nous effectuons des v\xe9rifications initiales sur le mot pour nous assurer qu'il est fait de 5 caract\xe8res uniquement alphab\xe9tiques, ce qui peut \xeatre refactoris\xe9 dans le futur ou v\xe9rifi\xe9 dans les commandes CLI."),(0,s.kt)("li",{parentName:"ul"},"Nous obtenons ensuite le mot du jour en r\xe9cup\xe9rant la chaine de hash du jour actuel."),(0,s.kt)("li",{parentName:"ul"},"Ensuite, nous cr\xe9ons une cha\xeene de hash du jour courant et l'Emetteur. Cela nous permet de cr\xe9er un type de devinette pour les mots propos\xe9s avec un index qui utilise le jour actuel et l'adresse de l'\xe9metteur. Cela nous aide quand nous sommes confront\xe9s \xe0 un nouveau jour et qu'une adresse veut deviner ce nouveau mot. La configuration de l'index permet de continuer \xe0 essayer de deviner un nouveau mot chaque jour jusqu'\xe0 un maximum de 6 essais par jour."),(0,s.kt)("li",{parentName:"ul"},"Nous v\xe9rifions ensuite si le nombre d'essais de l'\xe9metteur a bien atteint 6 pour aujourd'hui. Si ce n'est pas le cas, il incr\xe9mente l'essai. Nous v\xe9rifions ensuite si la tentative est correcte. Nous stockons la devinette avec le nombre d'essais mis \xe0 jour.")),(0,s.kt)("h2",{id:"le-fichier-protobuf"},"Le fichier Protobuf"),(0,s.kt)("p",null,"  Quelques fichiers doivent \xeatre modifi\xe9s pour que cela fonctionne."),(0,s.kt)("p",null,"Le premier est ",(0,s.kt)("inlineCode",{parentName:"p"},"proto/wordle/tx.proto"),"."),(0,s.kt)("p",null,"Dans ce fichier, remplissez le ",(0,s.kt)("inlineCode",{parentName:"p"},"MsgSubmitGuessResponse")," vide avec le code suivant :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"message MsgSubmitGuessResponse {\n  string title = 1;\n  string body = 2;\n}\n")),(0,s.kt)("p",null,"Le fichier suivant est : ",(0,s.kt)("inlineCode",{parentName:"p"},"x/wordle/types/expected_keepers.go")),(0,s.kt)("p",null,"Ici, nous avons besoin d'ajouter la m\xe9thode SendCoins \xe0 l'interface BankKeeper afin de permettre l'envoi de r\xe9compense \xe0 la personne qui a devin\xe9."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"type BankKeeper interface {\n  SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error\n}\n")),(0,s.kt)("p",null,"Avec cela, nous avons impl\xe9ment\xe9 toutes nos fonctions de Keeper! Il est temps de compiler la blockchain et de l'exposer pour un galop d'essai."))}c.isMDXComponent=!0}}]);