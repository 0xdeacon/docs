"use strict";(self.webpackChunkcelestia_docs=self.webpackChunkcelestia_docs||[]).push([[6468],{3905:function(e,t,a){a.d(t,{Zo:function(){return h},kt:function(){return u}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),m=c(a),u=s,d=m["".concat(l,".").concat(u)]||m[u]||p[u]||r;return a?n.createElement(d,o(o({ref:t},h),{},{components:a})):n.createElement(d,o({ref:t},h))}));function u(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,o=new Array(r);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4244:function(e,t,a){a.r(t),a.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return r},metadata:function(){return i},toc:function(){return c}});var n=a(3117),s=(a(7294),a(3905));const r={},o="Message Layout",i={unversionedId:"concepts/specifications/message-block-layout",id:"concepts/specifications/message-block-layout",title:"Message Layout",description:"- Preamble",source:"@site/docs/concepts/specifications/message-block-layout.md",sourceDirName:"concepts/specifications",slug:"/concepts/specifications/message-block-layout",permalink:"/pr-preview/pr-261/fr/concepts/specifications/message-block-layout",draft:!1,editUrl:"https://github.com/celestiaorg/docs/tree/main/docs/concepts/specifications/message-block-layout.md",tags:[],version:"current",frontMatter:{},sidebar:"concepts",previous:{title:"Fork Choice Rule with Data Availability Sampling",permalink:"/pr-preview/pr-261/fr/concepts/specifications/fork-choice-das"}},l={},c=[{value:"Preamble",id:"preamble",level:2},{value:"Message Layout Rationale",id:"message-layout-rationale",level:2},{value:"Non-Interactive Default Rules",id:"non-interactive-default-rules",level:3},{value:"Caveats",id:"caveats",level:3}],h={toc:c};function p(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"message-layout"},"Message Layout"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#preamble"},"Preamble")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#message-layout-rationale"},"Message Layout Rationale"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#non-interactive-default-rules"},"Non-Interactive Default Rules")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#caveats"},"Caveats"))))),(0,s.kt)("h2",{id:"preamble"},"Preamble"),(0,s.kt)("p",null,"Celestia uses ",(0,s.kt)("a",{parentName:"p",href:"https://arxiv.org/abs/1809.09044"},"a data availability scheme"),"\nthat allows nodes to determine whether a block's data was published without\ndownloading the whole block. The core of this scheme is arranging data in a\ntwo-dimensional matrix then applying erasure coding to each row and column.\nThis document describes the rationale for how data\u2014transactions, messages,\nand other data\u2014",(0,s.kt)("a",{parentName:"p",href:"https://celestiaorg.github.io/celestia-specs/latest/specs/data_structures.html#arranging-available-data-into-shares"},"is actually arranged"),".\nFamiliarity with the ",(0,s.kt)("a",{parentName:"p",href:"https://arxiv.org/abs/1809.09044"},"originally proposed data layout format"),"\nis assumed."),(0,s.kt)("h2",{id:"message-layout-rationale"},"Message Layout Rationale"),(0,s.kt)("p",null,"Block data consists of transactions (which modify the Celestia chain's state),\nintermediate state roots (required for fraud proofs of the aforementioned\ntransactions), messages (binary blobs which do not modify the Celestia state,\nbut which are intended for a Celestia application identified with a provided\nnamespace ID), and other relevant pieces of data (e.g. evidence for slashing).\nWe want to arrange this data into a ",(0,s.kt)("inlineCode",{parentName:"p"},"k * k")," matrix of fixed-sized shares,\nwhich will later be committed to in ",(0,s.kt)("a",{parentName:"p",href:"https://celestiaorg.github.io/celestia-specs/latest/specs/data_structures.html#namespace-merkle-tree"},"Namespace Merkle Trees (NMTs)"),"."),(0,s.kt)("p",null,"The simplest way we can imagine arranging block data is to simply serialize it\nall in no particular order, split it into fixed-sized shares, then arrange those\nshares into the ",(0,s.kt)("inlineCode",{parentName:"p"},"k * k")," matrix in row-major order. However, this naive scheme\ncan be improved in a number of ways, described below."),(0,s.kt)("p",null,"First, we impose some ground rules:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Data must be ordered by namespace ID. This makes queries into a NMT commitment\nof that data more efficient."),(0,s.kt)("li",{parentName:"ol"},"Since non-message data are not naturally intended for particular namespaces,\nwe assign reserved namespaces for them. A range of namespaces is reserved for\nthis purpose, starting from the lowest possible namespace ID."),(0,s.kt)("li",{parentName:"ol"},"By construction, the above two rules mean that non-message data always precedes\nmessage data in the row-major matrix, even when considering single rows or columns."),(0,s.kt)("li",{parentName:"ol"},"Data with different namespaces must not be in the same share. This might cause\na small amount of wasted block space, but makes the NMT easier to reason about\nin general since leaves are guaranteed to belong to a single namespace.")),(0,s.kt)("p",null,"Transactions can pay fees for a message to be included in the same block as the\ntransaction itself. However, we do not want serialized transactions to include\nthe entire message they pay for (which is the case in other blockchains with native\nexecution, e.g. calldata in Ethereum transactions or ",(0,s.kt)("inlineCode",{parentName:"p"},"OP_RETURN")," data in Bitcoin\ntransactions), otherwise every node that validates the sanctity of the Celestia\ncoin would need to download all message data. Transactions must therefore only\ninclude a commitment to (i.e. some hash of) the message they pay fees for. If\nimplemented naively (e.g. with a simple hash of the message, or a simple binary\nMerkle tree root of the message), this can lead to a data availability problem,\nas there are no guarantees that the data behind these commitments is actually\npart of the block data."),(0,s.kt)("p",null,"To that end, we impose some additional rules onto ",(0,s.kt)("em",{parentName:"p"},"messages only"),": messages must\nbe placed is a way such that both the transaction sender and the block producer\ncan be held accountable\u2014a necessary property for e.g. fee burning. Accountable in\nthis context means that:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The transaction sender must pay sufficient fees for message inclusion."),(0,s.kt)("li",{parentName:"ol"},"The block proposer cannot claim that a message was included when it was not\n(which implies that a transaction and the message it pays for must be included\nin the same block).")),(0,s.kt)("p",null,"Specifically, messages must begin at a new share, unlike non-message data which\ncan span multiple shares. We note a nice property from this rule: if the transaction\nsender knows 1) ",(0,s.kt)("inlineCode",{parentName:"p"},"k"),", the size of the matrix, 2) the starting location of their message\nin a row, and 3) the length of the message (they know this since they are sending\nthe message), then they can actually compute a sequence of roots to\n",(0,s.kt)("em",{parentName:"p"},"subtrees in the row NMTs"),". More importantly, anyone can compute this, and can\ncompute ",(0,s.kt)("em",{parentName:"p"},"the simple Merkle root of these subtree roots"),"."),(0,s.kt)("p",null,"This, however, requires the block producer to interact with the transaction sender\nto provide them the starting location of their message. This can be done selectively,\nbut is not ideal as a default for e.g. end-user wallets."),(0,s.kt)("h3",{id:"non-interactive-default-rules"},"Non-Interactive Default Rules"),(0,s.kt)("p",null,"As a non-consensus-critical default, we can impose some additional rules on message\nplacement to make the possible starting locations of messages sufficiently predictable\nand constrained such that users can deterministically compute subtree roots without\ninteraction:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Messages that span multiple rows must begin at the start of a row (this can occur\nif a message is longer than ",(0,s.kt)("inlineCode",{parentName:"li"},"k")," shares ",(0,s.kt)("em",{parentName:"li"},"or")," if the block producer decides to start\na message partway through a row and it cannot fit)."),(0,s.kt)("li",{parentName:"ol"},"Messages begin at a location aligned with the largest power of 2 that is not\nlarger than the message length or ",(0,s.kt)("inlineCode",{parentName:"li"},"k"),".")),(0,s.kt)("p",null,"With the above constraints, we can compute subtree roots deterministically easily:\nsimply slice off either the largest power of 2 that isn't larger than the remaining\nmessage length, or ",(0,s.kt)("inlineCode",{parentName:"p"},"k"),", whichever is smaller. This is done recursively. As an\nexample, with ",(0,s.kt)("inlineCode",{parentName:"p"},"k = 4")," and message length of ",(0,s.kt)("inlineCode",{parentName:"p"},"11"),", the message would be sliced with\nlengths ",(0,s.kt)("inlineCode",{parentName:"p"},"4, 4, 2, 1"),". The resulting slices are the leaves of subtrees whose roots\ncan be computed. Due to the rules above, the subtrees are guaranteed to be aligned\nto powers of 2, and thus the subtree roots will be present as internal nodes in\nthe NMT of ",(0,s.kt)("em",{parentName:"p"},"some")," row(s)."),(0,s.kt)("p",null,"This is similar to ",(0,s.kt)("a",{parentName:"p",href:"https://www.usenix.org/legacy/event/sec09/tech/full_papers/crosby.pdf"},"Merkle Mountain Ranges"),",\nthough with the largest subtree bounded by ",(0,s.kt)("inlineCode",{parentName:"p"},"k")," rather than being unbounded."),(0,s.kt)("p",null,"The last piece of the puzzle is determining ",(0,s.kt)("em",{parentName:"p"},"which")," row the message is placed\nat (or, more specifically, the starting location). This is needed to keep the\nblock producer accountable. To this end, the block producer simply augments\neach fee-paying transaction with some metadata: the starting location of the\nmessage the transaction pays for."),(0,s.kt)("h3",{id:"caveats"},"Caveats"),(0,s.kt)("p",null,"The message placement rules described above conflict with the first rule that\nshares must be ordered by namespace ID, as shares between two messages that are\nnot placed adjacent to each other do not have a natural namespace they belong to.\nThis is resolved by requiring that such shares have a value of zero and a namespace\nID equal to the preceding message's. Since their value is known, they can be omitted\nfrom NMT proofs of all shares of a given namespace ID."))}p.isMDXComponent=!0}}]);