"use strict";(self.webpackChunkcelestia_docs=self.webpackChunkcelestia_docs||[]).push([[3910],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var r=a.createContext({}),d=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(r.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),h=o,m=u["".concat(r,".").concat(h)]||u[h]||p[h]||i;return n?a.createElement(m,l(l({ref:t},c),{},{components:n})):a.createElement(m,l({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=u;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s.mdxType="string"==typeof e?e:o,l[1]=s;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7606:function(e,t,n){n.r(t),n.d(t,{assets:function(){return r},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return d}});var a=n(3117),o=(n(7294),n(3905));const i={sidebar_label:"Rollmint"},l="Rollmint",s={unversionedId:"developers/rollmint",id:"developers/rollmint",title:"Rollmint",description:"rollmint",source:"@site/docs/developers/rollmint.md",sourceDirName:"developers",slug:"/developers/rollmint",permalink:"/pr-preview/pr-296/ru/developers/rollmint",draft:!1,editUrl:"https://github.com/celestiaorg/docs/tree/main/docs/developers/rollmint.md",tags:[],version:"current",frontMatter:{sidebar_label:"Rollmint"},sidebar:"developers",previous:{title:"Node API",permalink:"/pr-preview/pr-296/ru/developers/node-api"},next:{title:"gm world",permalink:"/pr-preview/pr-296/ru/category/gm-world"}},r={},d=[{value:"Specifications of the Rollmint Scheme and Necessary Components",id:"specifications-of-the-rollmint-scheme-and-necessary-components",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Definitions",id:"definitions",level:4},{value:"Architecture Overview",id:"architecture-overview",level:4},{value:"Full Nodes",id:"full-nodes",level:5},{value:"Light Nodes",id:"light-nodes",level:5},{value:"Design Decisions &amp; Rationale",id:"design-decisions--rationale",level:4},{value:"Create an ABCI Client from Scratch",id:"create-an-abci-client-from-scratch",level:5},{value:"Add DA and Consensus Layer Client to ABCI Client",id:"add-da-and-consensus-layer-client-to-abci-client",level:5},{value:"Use Libp2p as a Peer-to-Peer networking Layer",id:"use-libp2p-as-a-peer-to-peer-networking-layer",level:5},{value:"Use IPFS and IPLD Plugin for Accessing Blocks and Block Chunks",id:"use-ipfs-and-ipld-plugin-for-accessing-blocks-and-block-chunks",level:5},{value:"Use Protocol Buffers (protobuf) for Serialization",id:"use-protocol-buffers-protobuf-for-serialization",level:5},{value:"Rather Long Block Times, so Fraud Proofs can be Gossiped before the Block is Complete",id:"rather-long-block-times-so-fraud-proofs-can-be-gossiped-before-the-block-is-complete",level:5},{value:"Components",id:"components",level:3},{value:"ABCI Client",id:"abci-client",level:4},{value:"Transaction Aggregation",id:"transaction-aggregation",level:5},{value:"ABCI Interface",id:"abci-interface",level:5},{value:"Mempool",id:"mempool",level:4},{value:"P2P Layer",id:"p2p-layer",level:5},{value:"Peer discovery",id:"peer-discovery",level:5},{value:"Transactions and Fraud Proof Gossiping",id:"transactions-and-fraud-proof-gossiping",level:5},{value:"Commits to Data Availability and Consensus Layer",id:"commits-to-data-availability-and-consensus-layer",level:4},{value:"Data Availability Checks",id:"data-availability-checks",level:5},{value:"Accessing Block Chunks",id:"accessing-block-chunks",level:5},{value:"Consensus",id:"consensus",level:5},{value:"Cosmos-SDK Rollmint module",id:"cosmos-sdk-rollmint-module",level:4},{value:"Sparse Merkle Trees",id:"sparse-merkle-trees",level:5},{value:"Intermediate State Roots",id:"intermediate-state-roots",level:5},{value:"Data Types and Message Formats",id:"data-types-and-message-formats",level:3},{value:"Block.Data",id:"blockdata",level:4},{value:"Fraud Proofs",id:"fraud-proofs",level:4},{value:"Tutorials",id:"tutorials",level:2}],c={toc:d};function p(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"rollmint"},"Rollmint"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"rollmint",src:n(6256).Z,width:"1280",height:"910"})),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/celestiaorg/rollmint"},"Rollmint")," is an ABCI\n(Application Blockchain Interface) implementation for sovereign\nrollups to deploy on top of Celestia."),(0,o.kt)("p",null,"It is built by replacing Tendermint, the Cosmos-SDK\nConsensus Layer, with a drop-in replacement that\ncommunicates directly with Celestia's Data Availability (DA) and Consensus Layer."),(0,o.kt)("p",null,"It spins up a sovereign rollup, which collects transactions into blocks and\nposts them onto Celestia for DA and Consensus."),(0,o.kt)("p",null,"The goal of Rollmint is to enable anyone to design and\ndeploy a sovereign rollup on Celestia in minutes with minimal overhead."),(0,o.kt)("p",null,'Furthermore, while Rollmint allows you to build sovereign rollups\non Celestia, it currently does not support fraud proofs yet and is\ntherefore running in "pessimistic" mode, where nodes would need to\nre-execute the transactions to check the validity of the chain\n(i.e. a full node). Furthermore, Rollmint currently only supports\na single sequencer.'),(0,o.kt)("h2",{id:"specifications-of-the-rollmint-scheme-and-necessary-components"},"Specifications of the Rollmint Scheme and Necessary Components"),(0,o.kt)("h3",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"This document provides an overview on how to implement Cosmos-SDK based Rollup\nchains. It goes into detail about how these chains can be built using Celestia\nas a Data Availability (DA) and Consensus Layer. At the same time we try to\nkeep the high level API general enough such that developers can choose\nalternative DA and Consensus Layers (e.g. Ethereum, the Cosmos Hub)."),(0,o.kt)("p",null,"We briefly compare building a Cosmos-SDK Rollmint chain with the status quo\n(building a sovereign Cosmos zone): The current way to use the Cosmos-SDK is to\ndefine the state-machine, also referred to as the Application. Application\ndevelopers do not have to bother about the lower Layers, namely consensus and"),(0,o.kt)("p",null,"networking. The lower Layers are currently handled by another\napplication-agnostic piece of the stack, namely the ABCI Client which defaults\nto ",(0,o.kt)("inlineCode",{parentName:"p"},"tendermint-core"),". We will replace the default ABCI Client with one that\ndoes not handle Consensus itself. Instead it will only provide the networking\nLayers, and will use the Consensus of the DA Layer. How exactly will be\ndescribed below:"),(0,o.kt)("p",null,"To summarize, if a current SDK-based app roughly follows the following\narchitecture:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"diagram1.png",src:n(7259).Z,width:"1110",height:"428"})),(0,o.kt)("p",null,"When implementing a Cosmos-SDK based Rollmint chain, this overview changes to:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"diagram2.png",src:n(4531).Z,width:"1218",height:"332"})),(0,o.kt)("p",null,"Note that from the point of view of an application developer, nothing changes.\nRollmint has the exact same developer experience as the usual Cosmos-SDK with\nTendermint provides: they still just have to define their business /\nstate-machine logic. The Rollmint-specific ABCI Client is stripped down to only\nhandle the network Layer but it also embeds a light node of the DA and\nConsensus Layer chain used and takes care of submitting the block to the DA\nand Consensus Layer. This can also be done with a Consensus Full Node."),(0,o.kt)("p",null,"As with Tendermint the state-machine and Rollmint interact with each other via\nABCI."),(0,o.kt)("h4",{id:"definitions"},"Definitions"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Rollmint Block Time")," - configurable duration after which a new block of\nthe (Rollmint chain) is produced."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Grace Period")," - configurable duration between block creation and block\nfinality. It\u2019s the time window for fraud proof submission.")),(0,o.kt)("h4",{id:"architecture-overview"},"Architecture Overview"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Rollmint aggregator sends block to main chain for DA and Consensus (Celestia,\nEthereum, Cosmos Hub)"),(0,o.kt)("li",{parentName:"ul"},"If time passes without fraud proof, the block is considered valid"),(0,o.kt)("li",{parentName:"ul"},"Else, if fraud proof, orphan all subsequent blocks"),(0,o.kt)("li",{parentName:"ul"},"With bond on Ethereum, or with longer block times and p2p gossip in\nside-chains subnet, or, liquidity providers")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"lazyledger-diagram.png",src:n(3180).Z,width:"799",height:"750"})),(0,o.kt)("h5",{id:"full-nodes"},"Full Nodes"),(0,o.kt)("p",null,"Full nodes are a crucial part of the networks, because they are responsible for\nproducing blocks and fraud proofs. They also create a link between the Rollmint\nnetwork and the DA and Consensus Layer, by pushing aggregates to the DA and\nConsensus Layer."),(0,o.kt)("h5",{id:"light-nodes"},"Light Nodes"),(0,o.kt)("p",null,"Light nodes are the main producer of transactions in the Rollmint network.\nThey participate in gossiping of and fraud proofs. Light\nnodes may only request or store a subset of the state, just to ensure that they\ncan execute rollback."),(0,o.kt)("h4",{id:"design-decisions--rationale"},"Design Decisions & Rationale"),(0,o.kt)("h5",{id:"create-an-abci-client-from-scratch"},"Create an ABCI Client from Scratch"),(0,o.kt)("p",null,"We discussed two approaches to creating an ABCI Client that does not explicitly\ndo consensus: ",(0,o.kt)("strong",{parentName:"p"},"1)")," adopting ",(0,o.kt)("inlineCode",{parentName:"p"},"tendermint-core")," to our needs and ",(0,o.kt)("strong",{parentName:"p"},"2)")," creating\nABCI Client from scratch as a drop-in replacement for Tendermint (discussion\nstarted ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/lazyledger/lazyledger-core/issues/62"},"here"),")."),(0,o.kt)("p",null,"We decided to create it from scratch. This gives us more flexibility and will\nresult in a cleaner design and more lightweight implementation. Also, this\ndecision still leaves room for using certain parts of the ",(0,o.kt)("inlineCode",{parentName:"p"},"tendermint-core")," code\nbase as a library where it makes sense to do so."),(0,o.kt)("h5",{id:"add-da-and-consensus-layer-client-to-abci-client"},"Add DA and Consensus Layer Client to ABCI Client"),(0,o.kt)("p",null,"Interacting with the DA and Consensus Layer could be added to either the\nABCI Client (Rollmint) or to the Cosmos-SDK (e.g. as a module). We decide to\nintegrate this into the ABCI Client because it fits better with the current\nphilosophy of separating the state-machine from the lower Layers. We plan to\nmake sure that the DA and Consensus Layer remains modular. This will be\nachieved by defining an interface which developers can implement to plug in\ntheir own DA and Consensus Layer client."),(0,o.kt)("h5",{id:"use-libp2p-as-a-peer-to-peer-networking-layer"},"Use Libp2p as a Peer-to-Peer networking Layer"),(0,o.kt)("p",null,"While we are aware of the shortcomings of Libp2p (e.g. as summarized in the\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.google.com/document/d/17OMi1MedOetF4Febijsc6KvGeNZdDQMb0yeC4QixOxw"},"Koyokan report"),"),\nwe decided to use it for Rollmint\u2019s p2p stack. Main reasons are that Libp2p is\none of most stable and popular P2P libraries available, with a relatively\nstable API with an upgrade path in case of breaking changes. It also provides\nmodules for most common tasks like peer discovery, gossiping, and Distributed\nHash Tables (DHTs). It is also used internally by IPFS - which we plan to use\n(see below)."),(0,o.kt)("h5",{id:"use-ipfs-and-ipld-plugin-for-accessing-blocks-and-block-chunks"},"Use IPFS and IPLD Plugin for Accessing Blocks and Block Chunks"),(0,o.kt)("p",null,"We have validated that using IPFS for DA and Consensus sampling and as a way to\nretrieve full blocks is feasible. We have noticed that we can likely improve\nlatencies by switching to Graphsync as a (IPLD) block exchange. Our first\nimplementation will still use bitswap which is the current default block\nexchange protocol used in IPFS."),(0,o.kt)("h5",{id:"use-protocol-buffers-protobuf-for-serialization"},"Use Protocol Buffers (protobuf) for Serialization"),(0,o.kt)("p",null,"Protocol Buffers (protobuf) is a well known and widely adopted serialization\nformat. It\u2019s both efficient and language-agnostic. It is also widely used in\nthe Cosmos ecosystem."),(0,o.kt)("h5",{id:"rather-long-block-times-so-fraud-proofs-can-be-gossiped-before-the-block-is-complete"},"Rather Long Block Times, so Fraud Proofs can be Gossiped before the Block is Complete"),(0,o.kt)("p",null,"We need to experiment with block times and grace period values to determine what\nworks best. Our first assumption is that Rollmint chain is not targeting short\nblock-times, something like 60 seconds sound reasonable. The grace period should\nbe significantly shorter, like 30 seconds. In such a scenario, we can assure\nthat no more than one block at a time will be rolled back."),(0,o.kt)("h3",{id:"components"},"Components"),(0,o.kt)("h4",{id:"abci-client"},"ABCI Client"),(0,o.kt)("h5",{id:"transaction-aggregation"},"Transaction Aggregation"),(0,o.kt)("p",null,"Transactions will be aggregated by full nodes. It is fundamentally the same\noperation as creating a block with ABCI interface. Multiple parameters should be\nconfigurable e.g. block time, maximum block size."),(0,o.kt)("h5",{id:"abci-interface"},"ABCI Interface"),(0,o.kt)("p",null,"ABCI is what will enable a relatively seamless replacement of Tendermint with\nRollmint. Of course the devil is in the detail and there is more to it than\nsimply replacing Tendermint with another piece of software that fulfils the\nclient side of the ABCI contract, e.g. the SDK spins up a Tendermint node. These\nplaces seem managable and having a clear interface between state-machine and the\nDA and Consensus Layer makes it possible to replace Tendermint with another\nABCI Client."),(0,o.kt)("p",null,"As we want to change as little as possible inside the SDK we will surely have to\nstick to the vanilla ABCI interface. That said, some of the properties we also\nwant for the Rollmint chains, e.g., that the intermediate state roots and the\nfinal state root (e.g. app-hash) of a block match the state transitions implied\nby the Transactions included in that very same block require changes in the ABCI\nitself. While ABCI++ is not part of this project\u2019s scope, we are\nclosely monitoring ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tendermint/spec/pull/254"},"ABCI++")," and\nplan to closely collaborate with Sikka on both specifying as well as\nfacilitating the implementation efforts by providing feedback or by implementing\nthe parts that we need in our forks."),(0,o.kt)("h4",{id:"mempool"},"Mempool"),(0,o.kt)("p",null,"The mempool keeps the set of pending transactions, and is used by block producers\n(full nodes) to produce blocks. Transactions are handled by nodes in the\nFirst-Come, First-Served (FCFS) manner. Ordering of transactions can be\nimplemented on the application level (for example by adding nonce/sequence\nnumber). This behaviour is similar to the Tendermint mempool."),(0,o.kt)("h5",{id:"p2p-layer"},"P2P Layer"),(0,o.kt)("p",null,"Full nodes and light nodes will be connected by the peer-to-peer network\nimplemented with Libp2p. There are many implementations of Publish-Subscribe\nmessaging pattern, but ",(0,o.kt)("inlineCode",{parentName:"p"},"libp2p-gossipsub")," is chosen because it\u2019s the most advanced\none."),(0,o.kt)("h5",{id:"peer-discovery"},"Peer discovery"),(0,o.kt)("p",null,"Initial peer discovery will be done via static configuration. Those\nbootstrap/seed nodes will then be used by ",(0,o.kt)("inlineCode",{parentName:"p"},"go-libp2p-discovery")," to connect to\nthe rest of the network and maintain a peer list."),(0,o.kt)("h5",{id:"transactions-and-fraud-proof-gossiping"},"Transactions and Fraud Proof Gossiping"),(0,o.kt)("p",null,"Transactions will be propagated in the P2P network using the gossiping mechanism."),(0,o.kt)("p",null,"Fraud proofs can be produced only by full nodes. They will be delivered to all\nnodes in the network with a gossiping mechanism. This will ensure that fraud\nproofs are delivered to all nodes as soon as possible, without delay (like\nwaiting on block finalization). If the grace period is shorter than block time,\nlight nodes don\u2019t need to keep historical data."),(0,o.kt)("h4",{id:"commits-to-data-availability-and-consensus-layer"},"Commits to Data Availability and Consensus Layer"),(0,o.kt)("p",null,"Rollmint needs to submit the block to the DA and Consensus Layer. For that it\nneeds to keep a light node of the DA and Consensus chain running. Additionally,\nit will need an account of that chain and sufficient balances for submitting a\nTransaction to the DA and Consensus chain."),(0,o.kt)("p",null,"Note that this only triggers a real state transition on the DA and Consensus\nchain. On the Rollmint chain successfully submitting the block to the DA and\nConseneus Layer (which includes it in its block) means that the Rollmint block\nwas finalized."),(0,o.kt)("p",null,"To keep the greatest flexibility, we start with the following very limited\ninterface and extend it only if necessary for implementing using Celestia as a\nDA and Consensus Layer (certainly in a way that would not limit developers to\nuse other DA and Consensus Layers though):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// TODO define an enum of different non-happy-path cases\n// that might need to be handled by Rollmint independent of\n// the underlying DA and Consensus chain.\ntype StatusCode uint64\n\ntype ResultSubmitBlock struct {\n  // Code is to determine if the action succeeded.\n  Code StatusCode\n  // Not sure if this needs to be bubbled up to other\n  // parts of Rollmint.\n  // Hash hash.Hash\n}\n\ntype DataAvailabilityLayerClient interface {\n  Start() error\n  Stop() error\n\n  // SubmitBlock submits the passed in block to the DA and Consensus Layer\n  // This should create a transaction which (potentially)\n  // triggers a state transition in the DA and Consensus Layer\n  SubmitBlock(block types.Block) ResultSubmitBlock\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SubmitBlock")," method will be called on an aggregator node before Rollmint\ntells the application (via ABCI) to commit the state (via the Commit method\nwhich might be renamed to ",(0,o.kt)("inlineCode",{parentName:"p"},"FinalizeBlock")," - see discussion on\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tendermint/spec/pull/254"},"ABCI++ PR"),"). Only if ",(0,o.kt)("inlineCode",{parentName:"p"},"SubmitBlock"),"\nsucceeds the application will update the state accordingly, otherwise the\naggregator has to retry or another aggregator node might do so before the\naggregator does (in that case we need a tie breaking rule, e.g.\nfirst-come-first-serve is a good start here, or, round-robin which would be more\nsimilar to using Tendermint). ",(0,o.kt)("inlineCode",{parentName:"p"},"Start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Stop")," are only called together with\nspinning up or shutting down the node respectively."),(0,o.kt)("h5",{id:"data-availability-checks"},"Data Availability Checks"),(0,o.kt)("h5",{id:"accessing-block-chunks"},"Accessing Block Chunks"),(0,o.kt)("p",null,"IPFS supplemented with Celestia IPLD plugin is able to access chunks of blocks.\nThanks to this functionality, light nodes can avoid downloading entire blocks\nfrom the DA and Consensus Layer. Instead, they can download only the parts they\nactually need."),(0,o.kt)("h5",{id:"consensus"},"Consensus"),(0,o.kt)("p",null,"The Rollmint chain will have no consensus rules. All valid transactions will be\naccepted by block creators. Fraud proofs will be the only way to detect and\nrollback malicious state transitions."),(0,o.kt)("h4",{id:"cosmos-sdk-rollmint-module"},"Cosmos-SDK Rollmint module"),(0,o.kt)("h5",{id:"sparse-merkle-trees"},"Sparse Merkle Trees"),(0,o.kt)("p",null,"The state of the Rollmint chain will be stored in a Sparse Merkle Tree. They can\nbe used to generate fraud proofs in very compact and easy to verify form."),(0,o.kt)("p",null,"Currently, we\u2019re actively participating in developing\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/pull/8430"},"a ",(0,o.kt)("inlineCode",{parentName:"a"},"proSeparation")," of storage and commitment (by the SMT) will allow the\noptimization of different components according to their usage and access patterns.")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/pull/8430"},"Proposal")," for replacing IAVL+\ntrees with SMTs for the entire state in Cosmos-SDK."),(0,o.kt)("h5",{id:"intermediate-state-roots"},"Intermediate State Roots"),(0,o.kt)("p",null,"To be able to validate fraud proofs, blocks of the Rollmint chain have to\ncontain intermediate state roots, reflecting the state of SMT after every transaction."),(0,o.kt)("h3",{id:"data-types-and-message-formats"},"Data Types and Message Formats"),(0,o.kt)("h4",{id:"blockdata"},"Block.Data"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Field"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"TXs")),(0,o.kt)("td",{parentName:"tr",align:null},"Transaction data")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"intermediateStateRoots")),(0,o.kt)("td",{parentName:"tr",align:null},"Intermediate state roots for each transaction")))),(0,o.kt)("h4",{id:"fraud-proofs"},"Fraud Proofs"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Field"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"blockHash")),(0,o.kt)("td",{parentName:"tr",align:null},"Hash of corresponding block header")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"preStateRoot")),(0,o.kt)("td",{parentName:"tr",align:null},"Root of Sparse Merkle Tree of the blockchain state before transaction")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"postStateRoot")),(0,o.kt)("td",{parentName:"tr",align:null},"Root of Sparse Merkle Tree of the blockchain state after transaction")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"transaction")),(0,o.kt)("td",{parentName:"tr",align:null},"Transaction (app specific)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"witness")),(0,o.kt)("td",{parentName:"tr",align:null},"Merkle Proofs")))),(0,o.kt)("h2",{id:"tutorials"},"Tutorials"),(0,o.kt)("p",null,"The following tutorials will help you get started building\nCosmos-SDK applications that connect to Celestia's Data Availability (DA) and Consensus\nLayer via Rollmint. We call those chains Sovereign Rollups."),(0,o.kt)("p",null,"You can get started with the following tutorials:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"./gm-world"},"gm world")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"./recipe-book"},"Recipe Book")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"./wordle"},"Wordle Game")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"./cosmwasm"},"CosmWasm Tutorial")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"./ethermint"},"Ethermint Tutorial"))))}p.isMDXComponent=!0},6256:function(e,t,n){t.Z=n.p+"assets/images/rollmint-5be7479f6bad05fad502a38ad0f3c5c6.png"},7259:function(e,t,n){t.Z=n.p+"assets/images/diagram1-886302b66665f99b2de49e0debfad8f9.png"},4531:function(e,t,n){t.Z=n.p+"assets/images/diagram2-1042c62dbd652094690b336c85823313.png"},3180:function(e,t,n){t.Z=n.p+"assets/images/lazyledger-diagram-0c4fa3da441db0873d3b330a6cae0a67.png"}}]);